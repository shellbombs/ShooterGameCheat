#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ShooterGame

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Gauntlet_classes.hpp"
#include "ShooterGame_structs.hpp"
#include "ReplicationGraph_structs.hpp"
#include "ReplicationGraph_classes.hpp"
#include "SlateCore_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"


namespace SDK
{

// Class ShooterGame.ShooterCharacter
// 0x01E0 (0x06A0 - 0x04C0)
class AShooterCharacter : public ACharacter
{
public:
	class USkeletalMeshComponent*                 Mesh1P;                                            // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponAttachPoint;                                 // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AShooterWeapon>>     DefaultInventoryClasses;                           // 0x04C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AShooterWeapon*>                 Inventory;                                         // 0x04D8(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AShooterWeapon*                         CurrentWeapon;                                     // 0x04E8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTakeHitInfo                           LastTakeHitInfo;                                   // 0x04F0(0x0128)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_156F[0x4];                                     // 0x0618(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetingSpeedModifier;                            // 0x061C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsTargeting : 1;                                  // 0x0620(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1570[0x3];                                     // 0x0621(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunningSpeedModifier;                              // 0x0624(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bWantsToRun : 1;                                   // 0x0628(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1571[0xF];                                     // 0x0629(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       MeshMIDs;                                          // 0x0638(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DeathAnim;                                         // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              DeathSound;                                        // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        RespawnFX;                                         // 0x0658(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              RespawnSound;                                      // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              LowHealthSound;                                    // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              RunLoopSound;                                      // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              RunStopSound;                                      // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              TargetingSound;                                    // 0x0680(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        RunLoopAC;                                         // 0x0688(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        LowHealthWarningPlayer;                            // 0x0690(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsDying : 1;                                      // 0x0698(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1572[0x3];                                     // 0x0699(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x069C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRep_CurrentWeapon(class AShooterWeapon* LastWeapon);
	void OnRep_LastTakeHitInfo();
	void ServerEquipWeapon(class AShooterWeapon* NewWeapon);
	void ServerSetRunning(bool bNewRunning, bool bToggle);
	void ServerSetTargeting(bool bNewTargeting);

	struct FRotator GetAimOffsets() const;
	float GetRunningSpeedModifier() const;
	float GetTargetingSpeedModifier() const;
	class AShooterWeapon* GetWeapon() const;
	bool IsFiring() const;
	bool IsFirstPerson() const;
	bool IsRunning() const;
	bool IsTargeting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterCharacter">();
	}
	static class AShooterCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterCharacter>();
	}
};
static_assert(alignof(AShooterCharacter) == 0x000010, "Wrong alignment on AShooterCharacter");
static_assert(sizeof(AShooterCharacter) == 0x0006A0, "Wrong size on AShooterCharacter");
static_assert(offsetof(AShooterCharacter, Mesh1P) == 0x0004B8, "Member 'AShooterCharacter::Mesh1P' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WeaponAttachPoint) == 0x0004C0, "Member 'AShooterCharacter::WeaponAttachPoint' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DefaultInventoryClasses) == 0x0004C8, "Member 'AShooterCharacter::DefaultInventoryClasses' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Inventory) == 0x0004D8, "Member 'AShooterCharacter::Inventory' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CurrentWeapon) == 0x0004E8, "Member 'AShooterCharacter::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LastTakeHitInfo) == 0x0004F0, "Member 'AShooterCharacter::LastTakeHitInfo' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, TargetingSpeedModifier) == 0x00061C, "Member 'AShooterCharacter::TargetingSpeedModifier' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RunningSpeedModifier) == 0x000624, "Member 'AShooterCharacter::RunningSpeedModifier' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MeshMIDs) == 0x000638, "Member 'AShooterCharacter::MeshMIDs' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DeathAnim) == 0x000648, "Member 'AShooterCharacter::DeathAnim' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DeathSound) == 0x000650, "Member 'AShooterCharacter::DeathSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RespawnFX) == 0x000658, "Member 'AShooterCharacter::RespawnFX' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RespawnSound) == 0x000660, "Member 'AShooterCharacter::RespawnSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LowHealthSound) == 0x000668, "Member 'AShooterCharacter::LowHealthSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RunLoopSound) == 0x000670, "Member 'AShooterCharacter::RunLoopSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RunStopSound) == 0x000678, "Member 'AShooterCharacter::RunStopSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, TargetingSound) == 0x000680, "Member 'AShooterCharacter::TargetingSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RunLoopAC) == 0x000688, "Member 'AShooterCharacter::RunLoopAC' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LowHealthWarningPlayer) == 0x000690, "Member 'AShooterCharacter::LowHealthWarningPlayer' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Health) == 0x00069C, "Member 'AShooterCharacter::Health' has a wrong offset!");

// Class ShooterGame.ShooterBot
// 0x0010 (0x06B0 - 0x06A0)
class AShooterBot : public AShooterCharacter
{
public:
	class UBehaviorTree*                          BotBehavior;                                       // 0x06A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1573[0x8];                                     // 0x06A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterBot">();
	}
	static class AShooterBot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterBot>();
	}
};
static_assert(alignof(AShooterBot) == 0x000010, "Wrong alignment on AShooterBot");
static_assert(sizeof(AShooterBot) == 0x0006B0, "Wrong size on AShooterBot");
static_assert(offsetof(AShooterBot, BotBehavior) == 0x0006A0, "Member 'AShooterBot::BotBehavior' has a wrong offset!");

// Class ShooterGame.ShooterTestControllerBase
// 0x0040 (0x0070 - 0x0030)
class UShooterTestControllerBase : public UGauntletTestController
{
public:
	uint8                                         Pad_1574[0x40];                                    // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterTestControllerBase">();
	}
	static class UShooterTestControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterTestControllerBase>();
	}
};
static_assert(alignof(UShooterTestControllerBase) == 0x000008, "Wrong alignment on UShooterTestControllerBase");
static_assert(sizeof(UShooterTestControllerBase) == 0x000070, "Wrong size on UShooterTestControllerBase");

// Class ShooterGame.ShooterTestControllerListenServerClient
// 0x0000 (0x0070 - 0x0070)
class UShooterTestControllerListenServerClient final : public UShooterTestControllerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterTestControllerListenServerClient">();
	}
	static class UShooterTestControllerListenServerClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterTestControllerListenServerClient>();
	}
};
static_assert(alignof(UShooterTestControllerListenServerClient) == 0x000008, "Wrong alignment on UShooterTestControllerListenServerClient");
static_assert(sizeof(UShooterTestControllerListenServerClient) == 0x000070, "Wrong size on UShooterTestControllerListenServerClient");

// Class ShooterGame.BTDecorator_HasLoSTo
// 0x0028 (0x0090 - 0x0068)
class UBTDecorator_HasLoSTo final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 EnemyKey;                                          // 0x0068(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasLoSTo">();
	}
	static class UBTDecorator_HasLoSTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasLoSTo>();
	}
};
static_assert(alignof(UBTDecorator_HasLoSTo) == 0x000008, "Wrong alignment on UBTDecorator_HasLoSTo");
static_assert(sizeof(UBTDecorator_HasLoSTo) == 0x000090, "Wrong size on UBTDecorator_HasLoSTo");
static_assert(offsetof(UBTDecorator_HasLoSTo, EnemyKey) == 0x000068, "Member 'UBTDecorator_HasLoSTo::EnemyKey' has a wrong offset!");

// Class ShooterGame.ShooterScoreboardWidgetStyle
// 0x0120 (0x0150 - 0x0030)
class UShooterScoreboardWidgetStyle final : public USlateWidgetStyleContainerBase
{
public:
	struct FShooterScoreboardStyle                ScoreboardStyle;                                   // 0x0030(0x0120)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterScoreboardWidgetStyle">();
	}
	static class UShooterScoreboardWidgetStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterScoreboardWidgetStyle>();
	}
};
static_assert(alignof(UShooterScoreboardWidgetStyle) == 0x000008, "Wrong alignment on UShooterScoreboardWidgetStyle");
static_assert(sizeof(UShooterScoreboardWidgetStyle) == 0x000150, "Wrong size on UShooterScoreboardWidgetStyle");
static_assert(offsetof(UShooterScoreboardWidgetStyle, ScoreboardStyle) == 0x000030, "Member 'UShooterScoreboardWidgetStyle::ScoreboardStyle' has a wrong offset!");

// Class ShooterGame.BTTask_FindPickup
// 0x0000 (0x0098 - 0x0098)
class UBTTask_FindPickup final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindPickup">();
	}
	static class UBTTask_FindPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindPickup>();
	}
};
static_assert(alignof(UBTTask_FindPickup) == 0x000008, "Wrong alignment on UBTTask_FindPickup");
static_assert(sizeof(UBTTask_FindPickup) == 0x000098, "Wrong size on UBTTask_FindPickup");

// Class ShooterGame.ShooterChatWidgetStyle
// 0x0908 (0x0938 - 0x0030)
class UShooterChatWidgetStyle final : public USlateWidgetStyleContainerBase
{
public:
	struct FShooterChatStyle                      ChatStyle;                                         // 0x0030(0x0908)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterChatWidgetStyle">();
	}
	static class UShooterChatWidgetStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterChatWidgetStyle>();
	}
};
static_assert(alignof(UShooterChatWidgetStyle) == 0x000008, "Wrong alignment on UShooterChatWidgetStyle");
static_assert(sizeof(UShooterChatWidgetStyle) == 0x000938, "Wrong size on UShooterChatWidgetStyle");
static_assert(offsetof(UShooterChatWidgetStyle, ChatStyle) == 0x000030, "Member 'UShooterChatWidgetStyle::ChatStyle' has a wrong offset!");

// Class ShooterGame.ShooterWeapon
// 0x0280 (0x04A0 - 0x0220)
class AShooterWeapon : public AActor
{
public:
	struct FCanvasIcon                            PrimaryIcon;                                       // 0x0220(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCanvasIcon                            SecondaryIcon;                                     // 0x0238(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCanvasIcon                            PrimaryClipIcon;                                   // 0x0250(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCanvasIcon                            SecondaryClipIcon;                                 // 0x0268(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AmmoIconsCount;                                    // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryClipIconOffset;                             // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryClipIconOffset;                           // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1575[0x4];                                     // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCanvasIcon                            Crosshair[0x5];                                    // 0x0290(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCanvasIcon                            AimingCrosshair[0x5];                              // 0x0308(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UseLaserDot;                                       // 0x0380(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomCrosshair;                                // 0x0381(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomAimingCrosshair;                          // 0x0382(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideCrosshairWhileNotAiming;                      // 0x0383(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerIntervalAdjustment;                           // 0x0384(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowAutomaticWeaponCatchup;                      // 0x0388(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1576[0x7];                                     // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AShooterCharacter*                      MyPawn;                                            // 0x0390(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FWeaponData                            WeaponConfig;                                      // 0x0398(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Mesh1P;                                            // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Mesh3P;                                            // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        FireAC;                                            // 0x03C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleAttachPoint;                                 // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MuzzleFX;                                          // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               MuzzlePSC;                                         // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               MuzzlePSCSecondary;                                // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatineeCameraShake>        FireCameraShake;                                   // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   FireForceFeedback;                                 // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              FireSound;                                         // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              FireLoopSound;                                     // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              FireFinishSound;                                   // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              OutOfAmmoSound;                                    // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ReloadSound;                                       // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FWeaponAnim                            ReloadAnim;                                        // 0x0420(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USoundCue*                              EquipSound;                                        // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FWeaponAnim                            EquipAnim;                                         // 0x0438(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponAnim                            FireAnim;                                          // 0x0448(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bLoopedMuzzleFX : 1;                               // 0x0458(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLoopedFireSound : 1;                              // 0x0458(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLoopedFireAnim : 1;                               // 0x0458(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_44 : 3;                                     // 0x0458(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bPendingReload : 1;                                // 0x0458(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1577[0x17];                                    // 0x0459(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentAmmo;                                       // 0x0470(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentAmmoInClip;                                 // 0x0474(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BurstCounter;                                      // 0x0478(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1578[0x24];                                    // 0x047C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientStartReload();
	void OnRep_BurstCounter();
	void OnRep_MyPawn();
	void OnRep_Reload();
	void ServerHandleFiring();
	void ServerStartFire();
	void ServerStartReload();
	void ServerStopFire();
	void ServerStopReload();

	class AShooterCharacter* GetPawnOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon">();
	}
	static class AShooterWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon>();
	}
};
static_assert(alignof(AShooterWeapon) == 0x000008, "Wrong alignment on AShooterWeapon");
static_assert(sizeof(AShooterWeapon) == 0x0004A0, "Wrong size on AShooterWeapon");
static_assert(offsetof(AShooterWeapon, PrimaryIcon) == 0x000220, "Member 'AShooterWeapon::PrimaryIcon' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, SecondaryIcon) == 0x000238, "Member 'AShooterWeapon::SecondaryIcon' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, PrimaryClipIcon) == 0x000250, "Member 'AShooterWeapon::PrimaryClipIcon' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, SecondaryClipIcon) == 0x000268, "Member 'AShooterWeapon::SecondaryClipIcon' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, AmmoIconsCount) == 0x000280, "Member 'AShooterWeapon::AmmoIconsCount' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, PrimaryClipIconOffset) == 0x000284, "Member 'AShooterWeapon::PrimaryClipIconOffset' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, SecondaryClipIconOffset) == 0x000288, "Member 'AShooterWeapon::SecondaryClipIconOffset' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, Crosshair) == 0x000290, "Member 'AShooterWeapon::Crosshair' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, AimingCrosshair) == 0x000308, "Member 'AShooterWeapon::AimingCrosshair' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, UseLaserDot) == 0x000380, "Member 'AShooterWeapon::UseLaserDot' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, UseCustomCrosshair) == 0x000381, "Member 'AShooterWeapon::UseCustomCrosshair' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, UseCustomAimingCrosshair) == 0x000382, "Member 'AShooterWeapon::UseCustomAimingCrosshair' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, bHideCrosshairWhileNotAiming) == 0x000383, "Member 'AShooterWeapon::bHideCrosshairWhileNotAiming' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, TimerIntervalAdjustment) == 0x000384, "Member 'AShooterWeapon::TimerIntervalAdjustment' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, bAllowAutomaticWeaponCatchup) == 0x000388, "Member 'AShooterWeapon::bAllowAutomaticWeaponCatchup' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MyPawn) == 0x000390, "Member 'AShooterWeapon::MyPawn' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, WeaponConfig) == 0x000398, "Member 'AShooterWeapon::WeaponConfig' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, Mesh1P) == 0x0003B0, "Member 'AShooterWeapon::Mesh1P' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, Mesh3P) == 0x0003B8, "Member 'AShooterWeapon::Mesh3P' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireAC) == 0x0003C0, "Member 'AShooterWeapon::FireAC' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzleAttachPoint) == 0x0003C8, "Member 'AShooterWeapon::MuzzleAttachPoint' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzleFX) == 0x0003D0, "Member 'AShooterWeapon::MuzzleFX' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzlePSC) == 0x0003D8, "Member 'AShooterWeapon::MuzzlePSC' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzlePSCSecondary) == 0x0003E0, "Member 'AShooterWeapon::MuzzlePSCSecondary' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireCameraShake) == 0x0003E8, "Member 'AShooterWeapon::FireCameraShake' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireForceFeedback) == 0x0003F0, "Member 'AShooterWeapon::FireForceFeedback' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireSound) == 0x0003F8, "Member 'AShooterWeapon::FireSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireLoopSound) == 0x000400, "Member 'AShooterWeapon::FireLoopSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireFinishSound) == 0x000408, "Member 'AShooterWeapon::FireFinishSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, OutOfAmmoSound) == 0x000410, "Member 'AShooterWeapon::OutOfAmmoSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, ReloadSound) == 0x000418, "Member 'AShooterWeapon::ReloadSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, ReloadAnim) == 0x000420, "Member 'AShooterWeapon::ReloadAnim' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, EquipSound) == 0x000430, "Member 'AShooterWeapon::EquipSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, EquipAnim) == 0x000438, "Member 'AShooterWeapon::EquipAnim' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireAnim) == 0x000448, "Member 'AShooterWeapon::FireAnim' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, CurrentAmmo) == 0x000470, "Member 'AShooterWeapon::CurrentAmmo' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, CurrentAmmoInClip) == 0x000474, "Member 'AShooterWeapon::CurrentAmmoInClip' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, BurstCounter) == 0x000478, "Member 'AShooterWeapon::BurstCounter' has a wrong offset!");

// Class ShooterGame.ShooterWeapon_Instant
// 0x0058 (0x04F8 - 0x04A0)
class AShooterWeapon_Instant : public AShooterWeapon
{
public:
	struct FInstantWeaponData                     InstantConfig;                                     // 0x04A0(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       ImpactTemplate;                                    // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        TrailFX;                                           // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TrailTargetParam;                                  // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInstantHitInfo                        HitNotify;                                         // 0x04E0(0x0014)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1579[0x4];                                     // 0x04F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_HitNotify();
	void ServerNotifyHit(const struct FHitResult& Impact, const struct FVector_NetQuantizeNormal& ShootDir, int32 RandomSeed, float ReticleSpread);
	void ServerNotifyMiss(const struct FVector_NetQuantizeNormal& ShootDir, int32 RandomSeed, float ReticleSpread);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Instant">();
	}
	static class AShooterWeapon_Instant* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Instant>();
	}
};
static_assert(alignof(AShooterWeapon_Instant) == 0x000008, "Wrong alignment on AShooterWeapon_Instant");
static_assert(sizeof(AShooterWeapon_Instant) == 0x0004F8, "Wrong size on AShooterWeapon_Instant");
static_assert(offsetof(AShooterWeapon_Instant, InstantConfig) == 0x0004A0, "Member 'AShooterWeapon_Instant::InstantConfig' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, ImpactTemplate) == 0x0004C8, "Member 'AShooterWeapon_Instant::ImpactTemplate' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, TrailFX) == 0x0004D0, "Member 'AShooterWeapon_Instant::TrailFX' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, TrailTargetParam) == 0x0004D8, "Member 'AShooterWeapon_Instant::TrailTargetParam' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, HitNotify) == 0x0004E0, "Member 'AShooterWeapon_Instant::HitNotify' has a wrong offset!");

// Class ShooterGame.BTTask_FindPointNearEnemy
// 0x0000 (0x0098 - 0x0098)
class UBTTask_FindPointNearEnemy final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindPointNearEnemy">();
	}
	static class UBTTask_FindPointNearEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindPointNearEnemy>();
	}
};
static_assert(alignof(UBTTask_FindPointNearEnemy) == 0x000008, "Wrong alignment on UBTTask_FindPointNearEnemy");
static_assert(sizeof(UBTTask_FindPointNearEnemy) == 0x000098, "Wrong size on UBTTask_FindPointNearEnemy");

// Class ShooterGame.ShooterAIController
// 0x0020 (0x0348 - 0x0328)
class AShooterAIController final : public AAIController
{
public:
	class UBlackboardComponent*                   BlackboardComp;                                    // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTreeComponent*                 BehaviorComp;                                      // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_157A[0x10];                                    // 0x0338(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FindClosestEnemy();
	bool FindClosestEnemyWithLOS(class AShooterCharacter* ExcludeEnemy);
	void ShootEnemy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterAIController">();
	}
	static class AShooterAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterAIController>();
	}
};
static_assert(alignof(AShooterAIController) == 0x000008, "Wrong alignment on AShooterAIController");
static_assert(sizeof(AShooterAIController) == 0x000348, "Wrong size on AShooterAIController");
static_assert(offsetof(AShooterAIController, BlackboardComp) == 0x000328, "Member 'AShooterAIController::BlackboardComp' has a wrong offset!");
static_assert(offsetof(AShooterAIController, BehaviorComp) == 0x000330, "Member 'AShooterAIController::BehaviorComp' has a wrong offset!");

// Class ShooterGame.ShooterCharacterMovement
// 0x0000 (0x0AF0 - 0x0AF0)
class UShooterCharacterMovement final : public UCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterCharacterMovement">();
	}
	static class UShooterCharacterMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterCharacterMovement>();
	}
};
static_assert(alignof(UShooterCharacterMovement) == 0x000010, "Wrong alignment on UShooterCharacterMovement");
static_assert(sizeof(UShooterCharacterMovement) == 0x000AF0, "Wrong size on UShooterCharacterMovement");

// Class ShooterGame.ShooterPlayerController
// 0x0078 (0x05E8 - 0x0570)
class AShooterPlayerController final : public APlayerController
{
public:
	uint8                                         bInfiniteAmmo : 1;                                 // 0x0570(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInfiniteClip : 1;                                 // 0x0570(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHealthRegen : 1;                                  // 0x0570(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bGodMode : 1;                                      // 0x0570(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_157C[0x68];                                    // 0x0571(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAnalogFireTrigger;                                // 0x05D9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_157D[0x2];                                     // 0x05DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FireTriggerThreshold;                              // 0x05DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_157E[0x8];                                     // 0x05E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientEndOnlineGame();
	void ClientGameStarted();
	void ClientSendRoundEndEvent(bool bIsWinner, int32 ExpendedTimeInSeconds);
	void ClientSetSpectatorCamera(const struct FVector& CameraLocation, const struct FRotator& CameraRotation);
	void ClientStartOnlineGame();
	void OnLeaderboardReadComplete(bool bWasSuccessful);
	void Say(const class FString& Msg);
	void ServerCheat(const class FString& Msg);
	void ServerSay(const class FString& Msg);
	void ServerSuicide();
	void SetGodMode(bool bEnable);
	void SimulateInputKey(const struct FKey& Key, bool bPressed);
	void Suicide();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPlayerController">();
	}
	static class AShooterPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPlayerController>();
	}
};
static_assert(alignof(AShooterPlayerController) == 0x000008, "Wrong alignment on AShooterPlayerController");
static_assert(sizeof(AShooterPlayerController) == 0x0005E8, "Wrong size on AShooterPlayerController");
static_assert(offsetof(AShooterPlayerController, bAnalogFireTrigger) == 0x0005D9, "Member 'AShooterPlayerController::bAnalogFireTrigger' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, FireTriggerThreshold) == 0x0005DC, "Member 'AShooterPlayerController::FireTriggerThreshold' has a wrong offset!");

// Class ShooterGame.ShooterTestControllerListenServerHost
// 0x0000 (0x0070 - 0x0070)
class UShooterTestControllerListenServerHost final : public UShooterTestControllerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterTestControllerListenServerHost">();
	}
	static class UShooterTestControllerListenServerHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterTestControllerListenServerHost>();
	}
};
static_assert(alignof(UShooterTestControllerListenServerHost) == 0x000008, "Wrong alignment on UShooterTestControllerListenServerHost");
static_assert(sizeof(UShooterTestControllerListenServerHost) == 0x000070, "Wrong size on UShooterTestControllerListenServerHost");

// Class ShooterGame.ShooterCheatManager
// 0x0000 (0x0088 - 0x0088)
class UShooterCheatManager final : public UCheatManager
{
public:
	void ChangeTeam(int32 NewTeamNumber);
	void Cheat(const class FString& Msg);
	void ForceMatchStart();
	void SpawnBot();
	void ToggleInfiniteAmmo();
	void ToggleInfiniteClip();
	void ToggleMatchTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterCheatManager">();
	}
	static class UShooterCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterCheatManager>();
	}
};
static_assert(alignof(UShooterCheatManager) == 0x000008, "Wrong alignment on UShooterCheatManager");
static_assert(sizeof(UShooterCheatManager) == 0x000088, "Wrong size on UShooterCheatManager");

// Class ShooterGame.ShooterDamageType
// 0x0028 (0x0068 - 0x0040)
class UShooterDamageType : public UDamageType
{
public:
	struct FCanvasIcon                            KillIcon;                                          // 0x0040(0x0018)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   HitForceFeedback;                                  // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   KilledForceFeedback;                               // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterDamageType">();
	}
	static class UShooterDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterDamageType>();
	}
};
static_assert(alignof(UShooterDamageType) == 0x000008, "Wrong alignment on UShooterDamageType");
static_assert(sizeof(UShooterDamageType) == 0x000068, "Wrong size on UShooterDamageType");
static_assert(offsetof(UShooterDamageType, KillIcon) == 0x000040, "Member 'UShooterDamageType::KillIcon' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, HitForceFeedback) == 0x000058, "Member 'UShooterDamageType::HitForceFeedback' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, KilledForceFeedback) == 0x000060, "Member 'UShooterDamageType::KilledForceFeedback' has a wrong offset!");

// Class ShooterGame.ShooterDemoSpectator
// 0x0028 (0x0598 - 0x0570)
class AShooterDemoSpectator final : public APlayerController
{
public:
	uint8                                         Pad_1581[0x28];                                    // 0x0570(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterDemoSpectator">();
	}
	static class AShooterDemoSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterDemoSpectator>();
	}
};
static_assert(alignof(AShooterDemoSpectator) == 0x000008, "Wrong alignment on AShooterDemoSpectator");
static_assert(sizeof(AShooterDemoSpectator) == 0x000598, "Wrong size on AShooterDemoSpectator");

// Class ShooterGame.ShooterTestControllerDedicatedServerTest
// 0x0000 (0x0070 - 0x0070)
class UShooterTestControllerDedicatedServerTest final : public UShooterTestControllerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterTestControllerDedicatedServerTest">();
	}
	static class UShooterTestControllerDedicatedServerTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterTestControllerDedicatedServerTest>();
	}
};
static_assert(alignof(UShooterTestControllerDedicatedServerTest) == 0x000008, "Wrong alignment on UShooterTestControllerDedicatedServerTest");
static_assert(sizeof(UShooterTestControllerDedicatedServerTest) == 0x000070, "Wrong size on UShooterTestControllerDedicatedServerTest");

// Class ShooterGame.ShooterEngine
// 0x0000 (0x0D70 - 0x0D70)
class UShooterEngine final : public UGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterEngine">();
	}
	static class UShooterEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterEngine>();
	}
};
static_assert(alignof(UShooterEngine) == 0x000008, "Wrong alignment on UShooterEngine");
static_assert(sizeof(UShooterEngine) == 0x000D70, "Wrong size on UShooterEngine");

// Class ShooterGame.ShooterExplosionEffect
// 0x00C0 (0x02E0 - 0x0220)
class AShooterExplosionEffect : public AActor
{
public:
	class UParticleSystem*                        ExplosionFX;                                       // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPointLightComponent*                   ExplosionLight;                                    // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosionLightFadeOut;                             // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1582[0x4];                                     // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              ExplosionSound;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDecalData                             Decal;                                             // 0x0240(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FHitResult                             SurfaceHit;                                        // 0x0250(0x0088)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1583[0x8];                                     // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterExplosionEffect">();
	}
	static class AShooterExplosionEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterExplosionEffect>();
	}
};
static_assert(alignof(AShooterExplosionEffect) == 0x000008, "Wrong alignment on AShooterExplosionEffect");
static_assert(sizeof(AShooterExplosionEffect) == 0x0002E0, "Wrong size on AShooterExplosionEffect");
static_assert(offsetof(AShooterExplosionEffect, ExplosionFX) == 0x000220, "Member 'AShooterExplosionEffect::ExplosionFX' has a wrong offset!");
static_assert(offsetof(AShooterExplosionEffect, ExplosionLight) == 0x000228, "Member 'AShooterExplosionEffect::ExplosionLight' has a wrong offset!");
static_assert(offsetof(AShooterExplosionEffect, ExplosionLightFadeOut) == 0x000230, "Member 'AShooterExplosionEffect::ExplosionLightFadeOut' has a wrong offset!");
static_assert(offsetof(AShooterExplosionEffect, ExplosionSound) == 0x000238, "Member 'AShooterExplosionEffect::ExplosionSound' has a wrong offset!");
static_assert(offsetof(AShooterExplosionEffect, Decal) == 0x000240, "Member 'AShooterExplosionEffect::Decal' has a wrong offset!");
static_assert(offsetof(AShooterExplosionEffect, SurfaceHit) == 0x000250, "Member 'AShooterExplosionEffect::SurfaceHit' has a wrong offset!");

// Class ShooterGame.ShooterGameMode
// 0x0060 (0x0368 - 0x0308)
class AShooterGameMode : public AGameMode
{
public:
	TSubclassOf<class APawn>                      BotPawnClass;                                      // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WarmupTime;                                        // 0x0310(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoundTime;                                         // 0x0314(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TimeBetweenMatches;                                // 0x0318(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KillScore;                                         // 0x031C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DeathScore;                                        // 0x0320(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageSelfScale;                                   // 0x0324(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxBots;                                           // 0x0328(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1584[0x4];                                     // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AShooterAIController*>           BotControllers;                                    // 0x0330(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterPlayerController>   PlatformPlayerControllerClass;                     // 0x0340(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1585[0x10];                                    // 0x0348(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AShooterPickup*>                 LevelPickups;                                      // 0x0358(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void FinishMatch();
	void SetAllowBots(bool bInAllowBots, int32 InMaxBots);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameMode">();
	}
	static class AShooterGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterGameMode>();
	}
};
static_assert(alignof(AShooterGameMode) == 0x000008, "Wrong alignment on AShooterGameMode");
static_assert(sizeof(AShooterGameMode) == 0x000368, "Wrong size on AShooterGameMode");
static_assert(offsetof(AShooterGameMode, BotPawnClass) == 0x000308, "Member 'AShooterGameMode::BotPawnClass' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, WarmupTime) == 0x000310, "Member 'AShooterGameMode::WarmupTime' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, RoundTime) == 0x000314, "Member 'AShooterGameMode::RoundTime' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, TimeBetweenMatches) == 0x000318, "Member 'AShooterGameMode::TimeBetweenMatches' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, KillScore) == 0x00031C, "Member 'AShooterGameMode::KillScore' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, DeathScore) == 0x000320, "Member 'AShooterGameMode::DeathScore' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, DamageSelfScale) == 0x000324, "Member 'AShooterGameMode::DamageSelfScale' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, MaxBots) == 0x000328, "Member 'AShooterGameMode::MaxBots' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, BotControllers) == 0x000330, "Member 'AShooterGameMode::BotControllers' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, PlatformPlayerControllerClass) == 0x000340, "Member 'AShooterGameMode::PlatformPlayerControllerClass' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, LevelPickups) == 0x000358, "Member 'AShooterGameMode::LevelPickups' has a wrong offset!");

// Class ShooterGame.ShooterGame_FreeForAll
// 0x0008 (0x0370 - 0x0368)
class AShooterGame_FreeForAll final : public AShooterGameMode
{
public:
	class AShooterPlayerState*                    WinnerPlayerState;                                 // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGame_FreeForAll">();
	}
	static class AShooterGame_FreeForAll* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterGame_FreeForAll>();
	}
};
static_assert(alignof(AShooterGame_FreeForAll) == 0x000008, "Wrong alignment on AShooterGame_FreeForAll");
static_assert(sizeof(AShooterGame_FreeForAll) == 0x000370, "Wrong size on AShooterGame_FreeForAll");
static_assert(offsetof(AShooterGame_FreeForAll, WinnerPlayerState) == 0x000368, "Member 'AShooterGame_FreeForAll::WinnerPlayerState' has a wrong offset!");

// Class ShooterGame.ShooterGame_Menu
// 0x0000 (0x02C0 - 0x02C0)
class AShooterGame_Menu final : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGame_Menu">();
	}
	static class AShooterGame_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterGame_Menu>();
	}
};
static_assert(alignof(AShooterGame_Menu) == 0x000008, "Wrong alignment on AShooterGame_Menu");
static_assert(sizeof(AShooterGame_Menu) == 0x0002C0, "Wrong size on AShooterGame_Menu");

// Class ShooterGame.ShooterGame_TeamDeathMatch
// 0x0008 (0x0370 - 0x0368)
class AShooterGame_TeamDeathMatch final : public AShooterGameMode
{
public:
	uint8                                         Pad_1587[0x8];                                     // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGame_TeamDeathMatch">();
	}
	static class AShooterGame_TeamDeathMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterGame_TeamDeathMatch>();
	}
};
static_assert(alignof(AShooterGame_TeamDeathMatch) == 0x000008, "Wrong alignment on AShooterGame_TeamDeathMatch");
static_assert(sizeof(AShooterGame_TeamDeathMatch) == 0x000370, "Wrong size on AShooterGame_TeamDeathMatch");

// Class ShooterGame.ShooterGameInstance
// 0x02A8 (0x0450 - 0x01A8)
class UShooterGameInstance final : public UGameInstance
{
public:
	class FString                                 WelcomeScreenMap;                                  // 0x01A8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MainMenuMap;                                       // 0x01B8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1588[0x288];                                   // 0x01C8(0x0288)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameInstance">();
	}
	static class UShooterGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterGameInstance>();
	}
};
static_assert(alignof(UShooterGameInstance) == 0x000008, "Wrong alignment on UShooterGameInstance");
static_assert(sizeof(UShooterGameInstance) == 0x000450, "Wrong size on UShooterGameInstance");
static_assert(offsetof(UShooterGameInstance, WelcomeScreenMap) == 0x0001A8, "Member 'UShooterGameInstance::WelcomeScreenMap' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, MainMenuMap) == 0x0001B8, "Member 'UShooterGameInstance::MainMenuMap' has a wrong offset!");

// Class ShooterGame.ShooterGameSession
// 0x0108 (0x0340 - 0x0238)
class AShooterGameSession final : public AGameSession
{
public:
	uint8                                         Pad_1589[0x108];                                   // 0x0238(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameSession">();
	}
	static class AShooterGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterGameSession>();
	}
};
static_assert(alignof(AShooterGameSession) == 0x000008, "Wrong alignment on AShooterGameSession");
static_assert(sizeof(AShooterGameSession) == 0x000340, "Wrong size on AShooterGameSession");

// Class ShooterGame.ShooterGameState
// 0x0148 (0x03D8 - 0x0290)
class AShooterGameState final : public AGameState
{
public:
	int32                                         NumTeams;                                          // 0x0290(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158A[0x4];                                     // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TeamScores;                                        // 0x0298(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         RemainingTime;                                     // 0x02A8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimerPaused;                                      // 0x02AC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158B[0x3];                                     // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActivityId;                                        // 0x02B0(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableGameFeedback;                               // 0x02C0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158C[0x117];                                   // 0x02C1(0x0117)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameState">();
	}
	static class AShooterGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterGameState>();
	}
};
static_assert(alignof(AShooterGameState) == 0x000008, "Wrong alignment on AShooterGameState");
static_assert(sizeof(AShooterGameState) == 0x0003D8, "Wrong size on AShooterGameState");
static_assert(offsetof(AShooterGameState, NumTeams) == 0x000290, "Member 'AShooterGameState::NumTeams' has a wrong offset!");
static_assert(offsetof(AShooterGameState, TeamScores) == 0x000298, "Member 'AShooterGameState::TeamScores' has a wrong offset!");
static_assert(offsetof(AShooterGameState, RemainingTime) == 0x0002A8, "Member 'AShooterGameState::RemainingTime' has a wrong offset!");
static_assert(offsetof(AShooterGameState, bTimerPaused) == 0x0002AC, "Member 'AShooterGameState::bTimerPaused' has a wrong offset!");
static_assert(offsetof(AShooterGameState, ActivityId) == 0x0002B0, "Member 'AShooterGameState::ActivityId' has a wrong offset!");
static_assert(offsetof(AShooterGameState, bEnableGameFeedback) == 0x0002C0, "Member 'AShooterGameState::bEnableGameFeedback' has a wrong offset!");

// Class ShooterGame.ShooterGameUserSettings
// 0x0020 (0x0140 - 0x0120)
class UShooterGameUserSettings final : public UGameUserSettings
{
public:
	int32                                         GraphicsQuality;                                   // 0x0120(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NVIDIAReflex;                                      // 0x0124(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LatencyFlashIndicator;                             // 0x0128(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FramerateVisibility;                               // 0x012C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GameToRenderVisibility;                            // 0x0130(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GameLatencyVisibility;                             // 0x0134(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RenderLatencyVisibility;                           // 0x0138(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLanMatch;                                       // 0x013C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDedicatedServer;                                // 0x013D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsForceSystemResolution;                          // 0x013E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158D[0x1];                                     // 0x013F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameUserSettings">();
	}
	static class UShooterGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterGameUserSettings>();
	}
};
static_assert(alignof(UShooterGameUserSettings) == 0x000008, "Wrong alignment on UShooterGameUserSettings");
static_assert(sizeof(UShooterGameUserSettings) == 0x000140, "Wrong size on UShooterGameUserSettings");
static_assert(offsetof(UShooterGameUserSettings, GraphicsQuality) == 0x000120, "Member 'UShooterGameUserSettings::GraphicsQuality' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, NVIDIAReflex) == 0x000124, "Member 'UShooterGameUserSettings::NVIDIAReflex' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, LatencyFlashIndicator) == 0x000128, "Member 'UShooterGameUserSettings::LatencyFlashIndicator' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, FramerateVisibility) == 0x00012C, "Member 'UShooterGameUserSettings::FramerateVisibility' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, GameToRenderVisibility) == 0x000130, "Member 'UShooterGameUserSettings::GameToRenderVisibility' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, GameLatencyVisibility) == 0x000134, "Member 'UShooterGameUserSettings::GameLatencyVisibility' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, RenderLatencyVisibility) == 0x000138, "Member 'UShooterGameUserSettings::RenderLatencyVisibility' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bIsLanMatch) == 0x00013C, "Member 'UShooterGameUserSettings::bIsLanMatch' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bIsDedicatedServer) == 0x00013D, "Member 'UShooterGameUserSettings::bIsDedicatedServer' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bIsForceSystemResolution) == 0x00013E, "Member 'UShooterGameUserSettings::bIsForceSystemResolution' has a wrong offset!");

// Class ShooterGame.ShooterGameViewportClient
// 0x0050 (0x03B0 - 0x0360)
class UShooterGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_158E[0x50];                                    // 0x0360(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameViewportClient">();
	}
	static class UShooterGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterGameViewportClient>();
	}
};
static_assert(alignof(UShooterGameViewportClient) == 0x000008, "Wrong alignment on UShooterGameViewportClient");
static_assert(sizeof(UShooterGameViewportClient) == 0x0003B0, "Wrong size on UShooterGameViewportClient");

// Class ShooterGame.ShooterPlayerController_Menu
// 0x0000 (0x0570 - 0x0570)
class AShooterPlayerController_Menu final : public APlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPlayerController_Menu">();
	}
	static class AShooterPlayerController_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPlayerController_Menu>();
	}
};
static_assert(alignof(AShooterPlayerController_Menu) == 0x000008, "Wrong alignment on AShooterPlayerController_Menu");
static_assert(sizeof(AShooterPlayerController_Menu) == 0x000570, "Wrong size on AShooterPlayerController_Menu");

// Class ShooterGame.ShooterHUD
// 0x0428 (0x0738 - 0x0310)
class AShooterHUD final : public AHUD
{
public:
	uint8                                         Pad_158F[0x38];                                    // 0x0310(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCanvasIcon                            HitNotifyIcon[0x8];                                // 0x0348(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            KillsBg;                                           // 0x0408(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            TimePlaceBg;                                       // 0x0420(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            PrimaryWeapBg;                                     // 0x0438(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            SecondaryWeapBg;                                   // 0x0450(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            Crosshair[0x5];                                    // 0x0468(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            HitNotifyCrosshair;                                // 0x04E0(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            DeathMessagesBg;                                   // 0x04F8(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            HealthBarBg;                                       // 0x0510(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            HealthBar;                                         // 0x0528(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            HealthIcon;                                        // 0x0540(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            KillsIcon;                                         // 0x0558(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            KilledIcon;                                        // 0x0570(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            TimerIcon;                                         // 0x0588(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            PlaceIcon;                                         // 0x05A0(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1590[0x90];                                    // 0x05B8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HitNotifyTexture;                                  // 0x0648(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             HUDMainTexture;                                    // 0x0650(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             HUDAssets02Texture;                                // 0x0658(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             LowHealthOverlayTexture;                           // 0x0660(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFont*                                  BigFont;                                           // 0x0668(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFont*                                  NormalFont;                                        // 0x0670(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1591[0xC0];                                    // 0x0678(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterHUD">();
	}
	static class AShooterHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterHUD>();
	}
};
static_assert(alignof(AShooterHUD) == 0x000008, "Wrong alignment on AShooterHUD");
static_assert(sizeof(AShooterHUD) == 0x000738, "Wrong size on AShooterHUD");
static_assert(offsetof(AShooterHUD, HitNotifyIcon) == 0x000348, "Member 'AShooterHUD::HitNotifyIcon' has a wrong offset!");
static_assert(offsetof(AShooterHUD, KillsBg) == 0x000408, "Member 'AShooterHUD::KillsBg' has a wrong offset!");
static_assert(offsetof(AShooterHUD, TimePlaceBg) == 0x000420, "Member 'AShooterHUD::TimePlaceBg' has a wrong offset!");
static_assert(offsetof(AShooterHUD, PrimaryWeapBg) == 0x000438, "Member 'AShooterHUD::PrimaryWeapBg' has a wrong offset!");
static_assert(offsetof(AShooterHUD, SecondaryWeapBg) == 0x000450, "Member 'AShooterHUD::SecondaryWeapBg' has a wrong offset!");
static_assert(offsetof(AShooterHUD, Crosshair) == 0x000468, "Member 'AShooterHUD::Crosshair' has a wrong offset!");
static_assert(offsetof(AShooterHUD, HitNotifyCrosshair) == 0x0004E0, "Member 'AShooterHUD::HitNotifyCrosshair' has a wrong offset!");
static_assert(offsetof(AShooterHUD, DeathMessagesBg) == 0x0004F8, "Member 'AShooterHUD::DeathMessagesBg' has a wrong offset!");
static_assert(offsetof(AShooterHUD, HealthBarBg) == 0x000510, "Member 'AShooterHUD::HealthBarBg' has a wrong offset!");
static_assert(offsetof(AShooterHUD, HealthBar) == 0x000528, "Member 'AShooterHUD::HealthBar' has a wrong offset!");
static_assert(offsetof(AShooterHUD, HealthIcon) == 0x000540, "Member 'AShooterHUD::HealthIcon' has a wrong offset!");
static_assert(offsetof(AShooterHUD, KillsIcon) == 0x000558, "Member 'AShooterHUD::KillsIcon' has a wrong offset!");
static_assert(offsetof(AShooterHUD, KilledIcon) == 0x000570, "Member 'AShooterHUD::KilledIcon' has a wrong offset!");
static_assert(offsetof(AShooterHUD, TimerIcon) == 0x000588, "Member 'AShooterHUD::TimerIcon' has a wrong offset!");
static_assert(offsetof(AShooterHUD, PlaceIcon) == 0x0005A0, "Member 'AShooterHUD::PlaceIcon' has a wrong offset!");
static_assert(offsetof(AShooterHUD, HitNotifyTexture) == 0x000648, "Member 'AShooterHUD::HitNotifyTexture' has a wrong offset!");
static_assert(offsetof(AShooterHUD, HUDMainTexture) == 0x000650, "Member 'AShooterHUD::HUDMainTexture' has a wrong offset!");
static_assert(offsetof(AShooterHUD, HUDAssets02Texture) == 0x000658, "Member 'AShooterHUD::HUDAssets02Texture' has a wrong offset!");
static_assert(offsetof(AShooterHUD, LowHealthOverlayTexture) == 0x000660, "Member 'AShooterHUD::LowHealthOverlayTexture' has a wrong offset!");
static_assert(offsetof(AShooterHUD, BigFont) == 0x000668, "Member 'AShooterHUD::BigFont' has a wrong offset!");
static_assert(offsetof(AShooterHUD, NormalFont) == 0x000670, "Member 'AShooterHUD::NormalFont' has a wrong offset!");

// Class ShooterGame.ShooterImpactEffect
// 0x0128 (0x0348 - 0x0220)
class AShooterImpactEffect : public AActor
{
public:
	class UParticleSystem*                        DefaultFX;                                         // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ConcreteFX;                                        // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        DirtFX;                                            // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        WaterFX;                                           // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        MetalFX;                                           // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        WoodFX;                                            // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GlassFX;                                           // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GrassFX;                                           // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FleshFX;                                           // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DefaultSound;                                      // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ConcreteSound;                                     // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DirtSound;                                         // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              WaterSound;                                        // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              MetalSound;                                        // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              WoodSound;                                         // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GlassSound;                                        // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GrassSound;                                        // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              FleshSound;                                        // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDecalData                             DefaultDecal;                                      // 0x02B0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FHitResult                             SurfaceHit;                                        // 0x02C0(0x0088)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterImpactEffect">();
	}
	static class AShooterImpactEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterImpactEffect>();
	}
};
static_assert(alignof(AShooterImpactEffect) == 0x000008, "Wrong alignment on AShooterImpactEffect");
static_assert(sizeof(AShooterImpactEffect) == 0x000348, "Wrong size on AShooterImpactEffect");
static_assert(offsetof(AShooterImpactEffect, DefaultFX) == 0x000220, "Member 'AShooterImpactEffect::DefaultFX' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, ConcreteFX) == 0x000228, "Member 'AShooterImpactEffect::ConcreteFX' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, DirtFX) == 0x000230, "Member 'AShooterImpactEffect::DirtFX' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, WaterFX) == 0x000238, "Member 'AShooterImpactEffect::WaterFX' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, MetalFX) == 0x000240, "Member 'AShooterImpactEffect::MetalFX' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, WoodFX) == 0x000248, "Member 'AShooterImpactEffect::WoodFX' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, GlassFX) == 0x000250, "Member 'AShooterImpactEffect::GlassFX' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, GrassFX) == 0x000258, "Member 'AShooterImpactEffect::GrassFX' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, FleshFX) == 0x000260, "Member 'AShooterImpactEffect::FleshFX' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, DefaultSound) == 0x000268, "Member 'AShooterImpactEffect::DefaultSound' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, ConcreteSound) == 0x000270, "Member 'AShooterImpactEffect::ConcreteSound' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, DirtSound) == 0x000278, "Member 'AShooterImpactEffect::DirtSound' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, WaterSound) == 0x000280, "Member 'AShooterImpactEffect::WaterSound' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, MetalSound) == 0x000288, "Member 'AShooterImpactEffect::MetalSound' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, WoodSound) == 0x000290, "Member 'AShooterImpactEffect::WoodSound' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, GlassSound) == 0x000298, "Member 'AShooterImpactEffect::GlassSound' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, GrassSound) == 0x0002A0, "Member 'AShooterImpactEffect::GrassSound' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, FleshSound) == 0x0002A8, "Member 'AShooterImpactEffect::FleshSound' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, DefaultDecal) == 0x0002B0, "Member 'AShooterImpactEffect::DefaultDecal' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, SurfaceHit) == 0x0002C0, "Member 'AShooterImpactEffect::SurfaceHit' has a wrong offset!");

// Class ShooterGame.ShooterLocalPlayer
// 0x0008 (0x0260 - 0x0258)
class UShooterLocalPlayer final : public ULocalPlayer
{
public:
	class UShooterPersistentUser*                 PersistentUser;                                    // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterLocalPlayer">();
	}
	static class UShooterLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterLocalPlayer>();
	}
};
static_assert(alignof(UShooterLocalPlayer) == 0x000008, "Wrong alignment on UShooterLocalPlayer");
static_assert(sizeof(UShooterLocalPlayer) == 0x000260, "Wrong size on UShooterLocalPlayer");
static_assert(offsetof(UShooterLocalPlayer, PersistentUser) == 0x000258, "Member 'UShooterLocalPlayer::PersistentUser' has a wrong offset!");

// Class ShooterGame.ShooterMenuItemWidgetStyle
// 0x01A0 (0x01D0 - 0x0030)
class UShooterMenuItemWidgetStyle final : public USlateWidgetStyleContainerBase
{
public:
	struct FShooterMenuItemStyle                  MenuItemStyle;                                     // 0x0030(0x01A0)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterMenuItemWidgetStyle">();
	}
	static class UShooterMenuItemWidgetStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterMenuItemWidgetStyle>();
	}
};
static_assert(alignof(UShooterMenuItemWidgetStyle) == 0x000008, "Wrong alignment on UShooterMenuItemWidgetStyle");
static_assert(sizeof(UShooterMenuItemWidgetStyle) == 0x0001D0, "Wrong size on UShooterMenuItemWidgetStyle");
static_assert(offsetof(UShooterMenuItemWidgetStyle, MenuItemStyle) == 0x000030, "Member 'UShooterMenuItemWidgetStyle::MenuItemStyle' has a wrong offset!");

// Class ShooterGame.ShooterMenuSoundsWidgetStyle
// 0x0038 (0x0068 - 0x0030)
class UShooterMenuSoundsWidgetStyle final : public USlateWidgetStyleContainerBase
{
public:
	struct FShooterMenuSoundsStyle                SoundsStyle;                                       // 0x0030(0x0038)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterMenuSoundsWidgetStyle">();
	}
	static class UShooterMenuSoundsWidgetStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterMenuSoundsWidgetStyle>();
	}
};
static_assert(alignof(UShooterMenuSoundsWidgetStyle) == 0x000008, "Wrong alignment on UShooterMenuSoundsWidgetStyle");
static_assert(sizeof(UShooterMenuSoundsWidgetStyle) == 0x000068, "Wrong size on UShooterMenuSoundsWidgetStyle");
static_assert(offsetof(UShooterMenuSoundsWidgetStyle, SoundsStyle) == 0x000030, "Member 'UShooterMenuSoundsWidgetStyle::SoundsStyle' has a wrong offset!");

// Class ShooterGame.ShooterMenuWidgetStyle
// 0x0200 (0x0230 - 0x0030)
class UShooterMenuWidgetStyle final : public USlateWidgetStyleContainerBase
{
public:
	struct FShooterMenuStyle                      MenuStyle;                                         // 0x0030(0x0200)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterMenuWidgetStyle">();
	}
	static class UShooterMenuWidgetStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterMenuWidgetStyle>();
	}
};
static_assert(alignof(UShooterMenuWidgetStyle) == 0x000008, "Wrong alignment on UShooterMenuWidgetStyle");
static_assert(sizeof(UShooterMenuWidgetStyle) == 0x000230, "Wrong size on UShooterMenuWidgetStyle");
static_assert(offsetof(UShooterMenuWidgetStyle, MenuStyle) == 0x000030, "Member 'UShooterMenuWidgetStyle::MenuStyle' has a wrong offset!");

// Class ShooterGame.ShooterOnlineSessionClient
// 0x0000 (0x01C8 - 0x01C8)
class UShooterOnlineSessionClient final : public UOnlineSessionClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterOnlineSessionClient">();
	}
	static class UShooterOnlineSessionClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterOnlineSessionClient>();
	}
};
static_assert(alignof(UShooterOnlineSessionClient) == 0x000008, "Wrong alignment on UShooterOnlineSessionClient");
static_assert(sizeof(UShooterOnlineSessionClient) == 0x0001C8, "Wrong size on UShooterOnlineSessionClient");

// Class ShooterGame.ShooterOptionsWidgetStyle
// 0x0038 (0x0068 - 0x0030)
class UShooterOptionsWidgetStyle final : public USlateWidgetStyleContainerBase
{
public:
	struct FShooterOptionsStyle                   OptionsStyle;                                      // 0x0030(0x0038)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterOptionsWidgetStyle">();
	}
	static class UShooterOptionsWidgetStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterOptionsWidgetStyle>();
	}
};
static_assert(alignof(UShooterOptionsWidgetStyle) == 0x000008, "Wrong alignment on UShooterOptionsWidgetStyle");
static_assert(sizeof(UShooterOptionsWidgetStyle) == 0x000068, "Wrong size on UShooterOptionsWidgetStyle");
static_assert(offsetof(UShooterOptionsWidgetStyle, OptionsStyle) == 0x000030, "Member 'UShooterOptionsWidgetStyle::OptionsStyle' has a wrong offset!");

// Class ShooterGame.ShooterPersistentUser
// 0x0048 (0x0070 - 0x0028)
class UShooterPersistentUser final : public USaveGame
{
public:
	int32                                         Kills;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Deaths;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Wins;                                              // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Losses;                                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BulletsFired;                                      // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RocketsFired;                                      // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BotsCount;                                         // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRecordingDemos;                                 // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1592[0x3];                                     // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Gamma;                                             // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimSensitivity;                                    // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvertedYAxis;                                    // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVibrationOpt;                                     // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1593[0x1E];                                    // 0x0052(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPersistentUser">();
	}
	static class UShooterPersistentUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterPersistentUser>();
	}
};
static_assert(alignof(UShooterPersistentUser) == 0x000008, "Wrong alignment on UShooterPersistentUser");
static_assert(sizeof(UShooterPersistentUser) == 0x000070, "Wrong size on UShooterPersistentUser");
static_assert(offsetof(UShooterPersistentUser, Kills) == 0x000028, "Member 'UShooterPersistentUser::Kills' has a wrong offset!");
static_assert(offsetof(UShooterPersistentUser, Deaths) == 0x00002C, "Member 'UShooterPersistentUser::Deaths' has a wrong offset!");
static_assert(offsetof(UShooterPersistentUser, Wins) == 0x000030, "Member 'UShooterPersistentUser::Wins' has a wrong offset!");
static_assert(offsetof(UShooterPersistentUser, Losses) == 0x000034, "Member 'UShooterPersistentUser::Losses' has a wrong offset!");
static_assert(offsetof(UShooterPersistentUser, BulletsFired) == 0x000038, "Member 'UShooterPersistentUser::BulletsFired' has a wrong offset!");
static_assert(offsetof(UShooterPersistentUser, RocketsFired) == 0x00003C, "Member 'UShooterPersistentUser::RocketsFired' has a wrong offset!");
static_assert(offsetof(UShooterPersistentUser, BotsCount) == 0x000040, "Member 'UShooterPersistentUser::BotsCount' has a wrong offset!");
static_assert(offsetof(UShooterPersistentUser, bIsRecordingDemos) == 0x000044, "Member 'UShooterPersistentUser::bIsRecordingDemos' has a wrong offset!");
static_assert(offsetof(UShooterPersistentUser, Gamma) == 0x000048, "Member 'UShooterPersistentUser::Gamma' has a wrong offset!");
static_assert(offsetof(UShooterPersistentUser, AimSensitivity) == 0x00004C, "Member 'UShooterPersistentUser::AimSensitivity' has a wrong offset!");
static_assert(offsetof(UShooterPersistentUser, bInvertedYAxis) == 0x000050, "Member 'UShooterPersistentUser::bInvertedYAxis' has a wrong offset!");
static_assert(offsetof(UShooterPersistentUser, bVibrationOpt) == 0x000051, "Member 'UShooterPersistentUser::bVibrationOpt' has a wrong offset!");

// Class ShooterGame.ShooterPickup
// 0x0040 (0x0260 - 0x0220)
class AShooterPickup : public AActor
{
public:
	class UParticleSystemComponent*               PickupPSC;                                         // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        ActiveFX;                                          // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        RespawningFX;                                      // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              PickupSound;                                       // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              RespawnSound;                                      // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnTime;                                       // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsActive : 1;                                     // 0x024C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1594[0x3];                                     // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AShooterCharacter*                      PickedUpBy;                                        // 0x0250(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1595[0x8];                                     // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPickedUpEvent();
	void OnRep_IsActive();
	void OnRespawnEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPickup">();
	}
	static class AShooterPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPickup>();
	}
};
static_assert(alignof(AShooterPickup) == 0x000008, "Wrong alignment on AShooterPickup");
static_assert(sizeof(AShooterPickup) == 0x000260, "Wrong size on AShooterPickup");
static_assert(offsetof(AShooterPickup, PickupPSC) == 0x000220, "Member 'AShooterPickup::PickupPSC' has a wrong offset!");
static_assert(offsetof(AShooterPickup, ActiveFX) == 0x000228, "Member 'AShooterPickup::ActiveFX' has a wrong offset!");
static_assert(offsetof(AShooterPickup, RespawningFX) == 0x000230, "Member 'AShooterPickup::RespawningFX' has a wrong offset!");
static_assert(offsetof(AShooterPickup, PickupSound) == 0x000238, "Member 'AShooterPickup::PickupSound' has a wrong offset!");
static_assert(offsetof(AShooterPickup, RespawnSound) == 0x000240, "Member 'AShooterPickup::RespawnSound' has a wrong offset!");
static_assert(offsetof(AShooterPickup, RespawnTime) == 0x000248, "Member 'AShooterPickup::RespawnTime' has a wrong offset!");
static_assert(offsetof(AShooterPickup, PickedUpBy) == 0x000250, "Member 'AShooterPickup::PickedUpBy' has a wrong offset!");

// Class ShooterGame.ShooterPickup_Ammo
// 0x0010 (0x0270 - 0x0260)
class AShooterPickup_Ammo : public AShooterPickup
{
public:
	int32                                         AmmoClips;                                         // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1596[0x4];                                     // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AShooterWeapon>             WeaponType;                                        // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPickup_Ammo">();
	}
	static class AShooterPickup_Ammo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPickup_Ammo>();
	}
};
static_assert(alignof(AShooterPickup_Ammo) == 0x000008, "Wrong alignment on AShooterPickup_Ammo");
static_assert(sizeof(AShooterPickup_Ammo) == 0x000270, "Wrong size on AShooterPickup_Ammo");
static_assert(offsetof(AShooterPickup_Ammo, AmmoClips) == 0x000260, "Member 'AShooterPickup_Ammo::AmmoClips' has a wrong offset!");
static_assert(offsetof(AShooterPickup_Ammo, WeaponType) == 0x000268, "Member 'AShooterPickup_Ammo::WeaponType' has a wrong offset!");

// Class ShooterGame.ShooterPickup_Health
// 0x0008 (0x0268 - 0x0260)
class AShooterPickup_Health : public AShooterPickup
{
public:
	int32                                         Health;                                            // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1597[0x4];                                     // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPickup_Health">();
	}
	static class AShooterPickup_Health* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPickup_Health>();
	}
};
static_assert(alignof(AShooterPickup_Health) == 0x000008, "Wrong alignment on AShooterPickup_Health");
static_assert(sizeof(AShooterPickup_Health) == 0x000268, "Wrong size on AShooterPickup_Health");
static_assert(offsetof(AShooterPickup_Health, Health) == 0x000260, "Member 'AShooterPickup_Health::Health' has a wrong offset!");

// Class ShooterGame.ShooterPlayerCameraManager
// 0x0010 (0x2820 - 0x2810)
class AShooterPlayerCameraManager final : public APlayerCameraManager
{
public:
	uint8                                         Pad_1598[0x10];                                    // 0x2810(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPlayerCameraManager">();
	}
	static class AShooterPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPlayerCameraManager>();
	}
};
static_assert(alignof(AShooterPlayerCameraManager) == 0x000010, "Wrong alignment on AShooterPlayerCameraManager");
static_assert(sizeof(AShooterPlayerCameraManager) == 0x002820, "Wrong size on AShooterPlayerCameraManager");

// Class ShooterGame.ShooterPlayerState
// 0x0028 (0x0348 - 0x0320)
class AShooterPlayerState final : public APlayerState
{
public:
	int32                                         TeamNumber;                                        // 0x0320(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumKills;                                          // 0x0324(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumDeaths;                                         // 0x0328(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumBulletsFired;                                   // 0x032C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumRocketsFired;                                   // 0x0330(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bQuitter : 1;                                      // 0x0334(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1599[0x3];                                     // 0x0335(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MatchID;                                           // 0x0338(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BroadcastDeath(class AShooterPlayerState* KillerPlayerState, const class UDamageType* KillerDamageType, class AShooterPlayerState* KilledPlayerState);
	void InformAboutKill(class AShooterPlayerState* KillerPlayerState, const class UDamageType* KillerDamageType, class AShooterPlayerState* KilledPlayerState);
	void OnRep_TeamColor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPlayerState">();
	}
	static class AShooterPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPlayerState>();
	}
};
static_assert(alignof(AShooterPlayerState) == 0x000008, "Wrong alignment on AShooterPlayerState");
static_assert(sizeof(AShooterPlayerState) == 0x000348, "Wrong size on AShooterPlayerState");
static_assert(offsetof(AShooterPlayerState, TeamNumber) == 0x000320, "Member 'AShooterPlayerState::TeamNumber' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, NumKills) == 0x000324, "Member 'AShooterPlayerState::NumKills' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, NumDeaths) == 0x000328, "Member 'AShooterPlayerState::NumDeaths' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, NumBulletsFired) == 0x00032C, "Member 'AShooterPlayerState::NumBulletsFired' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, NumRocketsFired) == 0x000330, "Member 'AShooterPlayerState::NumRocketsFired' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, MatchID) == 0x000338, "Member 'AShooterPlayerState::MatchID' has a wrong offset!");

// Class ShooterGame.ShooterProjectile
// 0x0050 (0x0270 - 0x0220)
class AShooterProjectile : public AActor
{
public:
	class UProjectileMovementComponent*           MovementComp;                                      // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       CollisionComp;                                     // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               ParticleComp;                                      // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AShooterExplosionEffect>    ExplosionTemplate;                                 // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159A[0x28];                                    // 0x0240(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExploded;                                         // 0x0268(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159B[0x7];                                     // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnImpact(const struct FHitResult& HitResult);
	void OnRep_Exploded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterProjectile">();
	}
	static class AShooterProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterProjectile>();
	}
};
static_assert(alignof(AShooterProjectile) == 0x000008, "Wrong alignment on AShooterProjectile");
static_assert(sizeof(AShooterProjectile) == 0x000270, "Wrong size on AShooterProjectile");
static_assert(offsetof(AShooterProjectile, MovementComp) == 0x000220, "Member 'AShooterProjectile::MovementComp' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, CollisionComp) == 0x000228, "Member 'AShooterProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, ParticleComp) == 0x000230, "Member 'AShooterProjectile::ParticleComp' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, ExplosionTemplate) == 0x000238, "Member 'AShooterProjectile::ExplosionTemplate' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, bExploded) == 0x000268, "Member 'AShooterProjectile::bExploded' has a wrong offset!");

// Class ShooterGame.ShooterReplicationGraph
// 0x0120 (0x05D0 - 0x04B0)
class UShooterReplicationGraph final : public UReplicationGraph
{
public:
	TArray<class UClass*>                         SpatializedClasses;                                // 0x04A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         NonSpatializedChildClasses;                        // 0x04B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         AlwaysRelevantClasses;                             // 0x04C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_GridSpatialization2D* GridNode;                                          // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_ActorList*        AlwaysRelevantNode;                                // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159C[0xE8];                                    // 0x04E8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterReplicationGraph">();
	}
	static class UShooterReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterReplicationGraph>();
	}
};
static_assert(alignof(UShooterReplicationGraph) == 0x000010, "Wrong alignment on UShooterReplicationGraph");
static_assert(sizeof(UShooterReplicationGraph) == 0x0005D0, "Wrong size on UShooterReplicationGraph");
static_assert(offsetof(UShooterReplicationGraph, SpatializedClasses) == 0x0004A8, "Member 'UShooterReplicationGraph::SpatializedClasses' has a wrong offset!");
static_assert(offsetof(UShooterReplicationGraph, NonSpatializedChildClasses) == 0x0004B8, "Member 'UShooterReplicationGraph::NonSpatializedChildClasses' has a wrong offset!");
static_assert(offsetof(UShooterReplicationGraph, AlwaysRelevantClasses) == 0x0004C8, "Member 'UShooterReplicationGraph::AlwaysRelevantClasses' has a wrong offset!");
static_assert(offsetof(UShooterReplicationGraph, GridNode) == 0x0004D8, "Member 'UShooterReplicationGraph::GridNode' has a wrong offset!");
static_assert(offsetof(UShooterReplicationGraph, AlwaysRelevantNode) == 0x0004E0, "Member 'UShooterReplicationGraph::AlwaysRelevantNode' has a wrong offset!");

// Class ShooterGame.ShooterReplicationGraphNode_AlwaysRelevant_ForConnection
// 0x0240 (0x0290 - 0x0050)
class UShooterReplicationGraphNode_AlwaysRelevant_ForConnection final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_159D[0x220];                                   // 0x0050(0x0220)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastPawn;                                          // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAlwaysRelevantActorInfo>       PastRelevantActors;                                // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_159E[0x8];                                     // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterReplicationGraphNode_AlwaysRelevant_ForConnection">();
	}
	static class UShooterReplicationGraphNode_AlwaysRelevant_ForConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterReplicationGraphNode_AlwaysRelevant_ForConnection>();
	}
};
static_assert(alignof(UShooterReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000008, "Wrong alignment on UShooterReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(sizeof(UShooterReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000290, "Wrong size on UShooterReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(offsetof(UShooterReplicationGraphNode_AlwaysRelevant_ForConnection, LastPawn) == 0x000270, "Member 'UShooterReplicationGraphNode_AlwaysRelevant_ForConnection::LastPawn' has a wrong offset!");
static_assert(offsetof(UShooterReplicationGraphNode_AlwaysRelevant_ForConnection, PastRelevantActors) == 0x000278, "Member 'UShooterReplicationGraphNode_AlwaysRelevant_ForConnection::PastRelevantActors' has a wrong offset!");

// Class ShooterGame.ShooterReplicationGraphNode_PlayerStateFrequencyLimiter
// 0x0028 (0x0078 - 0x0050)
class UShooterReplicationGraphNode_PlayerStateFrequencyLimiter final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_159F[0x28];                                    // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterReplicationGraphNode_PlayerStateFrequencyLimiter">();
	}
	static class UShooterReplicationGraphNode_PlayerStateFrequencyLimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterReplicationGraphNode_PlayerStateFrequencyLimiter>();
	}
};
static_assert(alignof(UShooterReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000008, "Wrong alignment on UShooterReplicationGraphNode_PlayerStateFrequencyLimiter");
static_assert(sizeof(UShooterReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000078, "Wrong size on UShooterReplicationGraphNode_PlayerStateFrequencyLimiter");

// Class ShooterGame.ShooterSpectatorPawn
// 0x0000 (0x02A8 - 0x02A8)
class AShooterSpectatorPawn final : public ASpectatorPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterSpectatorPawn">();
	}
	static class AShooterSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterSpectatorPawn>();
	}
};
static_assert(alignof(AShooterSpectatorPawn) == 0x000008, "Wrong alignment on AShooterSpectatorPawn");
static_assert(sizeof(AShooterSpectatorPawn) == 0x0002A8, "Wrong size on AShooterSpectatorPawn");

// Class ShooterGame.ShooterTeamStart
// 0x0008 (0x0258 - 0x0250)
class AShooterTeamStart final : public APlayerStart
{
public:
	int32                                         SpawnTeam;                                         // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNotForPlayers : 1;                                // 0x0254(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNotForBots : 1;                                   // 0x0254(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15A0[0x3];                                     // 0x0255(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterTeamStart">();
	}
	static class AShooterTeamStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterTeamStart>();
	}
};
static_assert(alignof(AShooterTeamStart) == 0x000008, "Wrong alignment on AShooterTeamStart");
static_assert(sizeof(AShooterTeamStart) == 0x000258, "Wrong size on AShooterTeamStart");
static_assert(offsetof(AShooterTeamStart, SpawnTeam) == 0x000250, "Member 'AShooterTeamStart::SpawnTeam' has a wrong offset!");

// Class ShooterGame.ShooterTestControllerBasicDedicatedServerTest
// 0x0000 (0x0070 - 0x0070)
class UShooterTestControllerBasicDedicatedServerTest final : public UShooterTestControllerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterTestControllerBasicDedicatedServerTest">();
	}
	static class UShooterTestControllerBasicDedicatedServerTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterTestControllerBasicDedicatedServerTest>();
	}
};
static_assert(alignof(UShooterTestControllerBasicDedicatedServerTest) == 0x000008, "Wrong alignment on UShooterTestControllerBasicDedicatedServerTest");
static_assert(sizeof(UShooterTestControllerBasicDedicatedServerTest) == 0x000070, "Wrong size on UShooterTestControllerBasicDedicatedServerTest");

// Class ShooterGame.ShooterTestControllerBootTest
// 0x0008 (0x0038 - 0x0030)
class UShooterTestControllerBootTest final : public UGauntletTestControllerBootTest
{
public:
	uint8                                         Pad_15A1[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterTestControllerBootTest">();
	}
	static class UShooterTestControllerBootTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterTestControllerBootTest>();
	}
};
static_assert(alignof(UShooterTestControllerBootTest) == 0x000008, "Wrong alignment on UShooterTestControllerBootTest");
static_assert(sizeof(UShooterTestControllerBootTest) == 0x000038, "Wrong size on UShooterTestControllerBootTest");

// Class ShooterGame.ShooterTestControllerListenServerQuickMatchClient
// 0x0000 (0x0070 - 0x0070)
class UShooterTestControllerListenServerQuickMatchClient final : public UShooterTestControllerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterTestControllerListenServerQuickMatchClient">();
	}
	static class UShooterTestControllerListenServerQuickMatchClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterTestControllerListenServerQuickMatchClient>();
	}
};
static_assert(alignof(UShooterTestControllerListenServerQuickMatchClient) == 0x000008, "Wrong alignment on UShooterTestControllerListenServerQuickMatchClient");
static_assert(sizeof(UShooterTestControllerListenServerQuickMatchClient) == 0x000070, "Wrong size on UShooterTestControllerListenServerQuickMatchClient");

// Class ShooterGame.ShooterWeapon_Projectile
// 0x0020 (0x04C0 - 0x04A0)
class AShooterWeapon_Projectile : public AShooterWeapon
{
public:
	struct FProjectileWeaponData                  ProjectileConfig;                                  // 0x04A0(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void ServerFireProjectile(const struct FVector& Origin, const struct FVector_NetQuantizeNormal& ShootDir);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Projectile">();
	}
	static class AShooterWeapon_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Projectile>();
	}
};
static_assert(alignof(AShooterWeapon_Projectile) == 0x000008, "Wrong alignment on AShooterWeapon_Projectile");
static_assert(sizeof(AShooterWeapon_Projectile) == 0x0004C0, "Wrong size on AShooterWeapon_Projectile");
static_assert(offsetof(AShooterWeapon_Projectile, ProjectileConfig) == 0x0004A0, "Member 'AShooterWeapon_Projectile::ProjectileConfig' has a wrong offset!");

// Class ShooterGame.SoundNodeLocalPlayer
// 0x0000 (0x0048 - 0x0048)
class USoundNodeLocalPlayer final : public USoundNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeLocalPlayer">();
	}
	static class USoundNodeLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeLocalPlayer>();
	}
};
static_assert(alignof(USoundNodeLocalPlayer) == 0x000008, "Wrong alignment on USoundNodeLocalPlayer");
static_assert(sizeof(USoundNodeLocalPlayer) == 0x000048, "Wrong size on USoundNodeLocalPlayer");

}

